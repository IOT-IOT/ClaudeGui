@page "/"
@using ClaudeGui.Blazor.Components
@using ClaudeGui.Blazor.Services
@using ClaudeGui.Blazor.Models
@inject ITerminalManager TerminalManager
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject DbService DbService
@inject SessionEventService SessionEvents

<PageTitle>ClaudeGui - Terminal Sessions</PageTitle>

<div class="claude-gui-container">
    <!-- Header Section -->
    <div class="header-section">
        <div class="logo-title">
            <h1>ü§ñ ClaudeGui</h1>
            <p class="subtitle">Web-based Claude Code Terminal</p>
        </div>
    </div>

    <!-- Terminal Section: 3-Panel Layout (Claude | Markdown Editor | PowerShell) -->
    @if (_openTerminals.Any())
    {
        <!-- Render tutti i terminal, nascondendo quelli inattivi con display:none -->
        @foreach (var terminal in _openTerminals)
        {
            <div class="session-view" style="display: @(terminal.Key == _activeTerminalKey ? "grid" : "none")">
                <!-- Left Panel: Claude Terminal -->
                <div class="panel claude-panel">
                    <Terminal @key="@($"{terminal.Key}-claude")"
                             Type="TerminalType.Claude"
                             WorkingDirectory="@terminal.WorkingDirectory"
                             ExistingSessionId="@terminal.SessionId"
                             SessionName="@terminal.SessionName"
                             OnSessionInitialized="(connectionId) => HandleClaudeSessionInitialized(terminal.Key, connectionId)"
                             OnSessionIdDetected="(sessionId) => OnClaudeSessionIdDetected(terminal.Key, sessionId)"
                             OnProcessCompleted="() => HandleProcessCompleted(terminal.Key)" />
                </div>

                <!-- Center Panel: Markdown Editor -->
                <div class="panel editor-panel">
                    <MarkdownEditor @key="@($"{terminal.Key}-editor")"
                                   SessionId="@terminal.DetectedClaudeSessionId"
                                   WorkingDirectory="@terminal.WorkingDirectory" />
                </div>

                <!-- Right Panel: PowerShell Terminal -->
                <div class="panel powershell-panel">
                    @if (!string.IsNullOrEmpty(terminal.DetectedClaudeSessionId))
                    {
                        <Terminal @key="@($"{terminal.Key}-powershell")"
                                 Type="TerminalType.PowerShell"
                                 WorkingDirectory="@terminal.WorkingDirectory"
                                 ExistingSessionId="@terminal.DetectedClaudeSessionId"
                                 OnSessionInitialized="(connectionId) => HandlePowerShellSessionInitialized(terminal.Key, connectionId)"
                                 OnProcessCompleted="() => {}" />
                    }
                    else
                    {
                        <div class="powershell-placeholder">
                            <div class="spinner"></div>
                            <p>Waiting for Claude Session ID...</p>
                        </div>
                    }
                </div>
            </div>
        }
    }

    <!-- Status Bar -->
    @if (!string.IsNullOrEmpty(_statusMessage))
    {
        <div class="status-bar @_statusClass">
            @_statusMessage
        </div>
    }

    <!-- New Session Modal -->
    <NewSessionModal OnSessionCreated="HandleSessionCreated" />
</div>

@code {
    // Query Parameters (dal NavMenu quando si clicca una sessione)
    [SupplyParameterFromQuery(Name = "sessionId")]
    public string? QuerySessionId { get; set; }

    [SupplyParameterFromQuery(Name = "sessionName")]
    public string? QuerySessionName { get; set; }

    [SupplyParameterFromQuery(Name = "workingDir")]
    public string? QueryWorkingDir { get; set; }

    [SupplyParameterFromQuery(Name = "isOpen")]
    public bool QueryIsOpen { get; set; }

    // State - Multi-terminal support
    private List<TerminalInstance> _openTerminals = new();
    private string? _activeTerminalKey = null; // Chiave del terminal attualmente visualizzato
    private string? _statusMessage = null;
    private string _statusClass = "info";
    private bool _hasAutoLaunched = false; // Flag per evitare multipli auto-launch

    /// <summary>
    /// Rappresenta un'istanza di terminal aperta con 3 panel (Claude + Editor + PowerShell).
    /// </summary>
    private class TerminalInstance
    {
        public string Key { get; set; } = Guid.NewGuid().ToString();
        public string? ConnectionId { get; set; } // SignalR ConnectionId del terminal Claude (impostato dopo init)
        public string? SessionId { get; set; } // Claude Session UUID iniziale (per resume)
        public string? DetectedClaudeSessionId { get; set; } // Claude Session UUID rilevato da /status (per nuove sessioni)
        public string? SessionName { get; set; }
        public string WorkingDirectory { get; set; } = "C:\\temp";
        public string? PowerShellConnectionId { get; set; } // SignalR ConnectionId del terminal PowerShell
    }

    /// <summary>
    /// OnInitializedAsync: carica ultima sessione open all'avvio (solo se nessun query parameter).
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        // Auto-launch ultima sessione open solo se NON ci sono query parameters
        if (string.IsNullOrEmpty(QuerySessionId) && !_hasAutoLaunched)
        {
            try
            {
                // Ottieni ultima sessione open dal DB (OrderByDescending LastActivity)
                var openSessions = await DbService.GetOpenSessionsAsync();
                var lastSession = openSessions.FirstOrDefault();

                if (lastSession != null)
                {
                    _hasAutoLaunched = true;
                    ResumeSession(lastSession.SessionId, lastSession.Name, lastSession.WorkingDirectory);
                    SetStatus($"Auto-launched last session: {lastSession.Name ?? lastSession.SessionId.Substring(0, 8)}", "info");
                }
            }
            catch (Exception ex)
            {
                SetStatus($"Error auto-launching last session: {ex.Message}", "error");
            }
        }
    }

    /// <summary>
    /// OnParametersSet: gestisce navigazione da NavMenu tramite query parameters.
    /// Avvia automaticamente il terminal quando vengono passati sessionId e workingDir.
    /// </summary>
    protected override void OnParametersSet()
    {
        // Se abbiamo query parameters per una sessione, avvia il terminal
        if (!string.IsNullOrEmpty(QuerySessionId) && !string.IsNullOrEmpty(QueryWorkingDir))
        {
            // Resume/attach alla sessione selezionata
            ResumeSession(QuerySessionId, QuerySessionName, QueryWorkingDir);
        }
    }

    /// <summary>
    /// Handler chiamato dal NewSessionModal quando una sessione viene creata.
    /// Riceve sessionName e workingDirectory dal modal e avvia il terminal.
    /// La validazione √® gi√† stata eseguita dal modal.
    /// </summary>
    private void HandleSessionCreated((string sessionName, string workingDirectory) sessionData)
    {
        // Crea nuovo TerminalInstance e aggiungilo alla lista
        var newTerminal = new TerminalInstance
        {
            SessionName = sessionData.sessionName,
            WorkingDirectory = sessionData.workingDirectory,
            SessionId = null // Nuova sessione (ConnectionId sar√† impostato in OnSessionInitialized)
        };

        _openTerminals.Add(newTerminal);
        _activeTerminalKey = newTerminal.Key; // Rendi attivo il nuovo terminal

        SetStatus($"Starting new session '{sessionData.sessionName}'...", "info");
    }

    /// <summary>
    /// Riprende una sessione esistente (attiva o da database).
    /// Se terminal gi√† aperto in UI ‚Üí solo switch visualizzazione (NO modifica DB).
    /// Altrimenti crea nuovo terminal con --resume.
    /// </summary>
    private void ResumeSession(string sessionId, string? sessionName, string? workingDirectory = null)
    {
        // CASO 1: Terminal gi√† aperto in UI ‚Üí solo switch visualizzazione
        var existingTerminal = _openTerminals.FirstOrDefault(t =>
            t.SessionId == sessionId ||
            t.ConnectionId == sessionId);

        if (existingTerminal != null)
        {
            // Terminal gi√† presente ‚Üí solo cambia visualizzazione (NO modifica DB!)
            _activeTerminalKey = existingTerminal.Key;
            SetStatus($"Switched to session {sessionName ?? sessionId.Substring(0, 8)}", "info");
            return;
        }

        // CASO 2: Sessione attiva in TerminalManager ma non in UI ‚Üí crea terminal per collegarsi
        if (TerminalManager.HasActiveSession(sessionId))
        {
            var connectionId = TerminalManager.GetConnectionIdByClaudeSessionId(sessionId);
            if (connectionId != null)
            {
                var newTerminal = new TerminalInstance
                {
                    SessionId = sessionId,
                    SessionName = sessionName,
                    WorkingDirectory = workingDirectory ?? "C:\\temp",
                    ConnectionId = connectionId
                };
                _openTerminals.Add(newTerminal);
                _activeTerminalKey = newTerminal.Key;
                SetStatus($"Attached to running session {sessionName ?? sessionId.Substring(0, 8)}", "success");
                return;
            }
        }

        // CASO 3: Sessione closed nel DB ‚Üí avvia nuovo processo con --resume
        var resumeTerminal = new TerminalInstance
        {
            SessionId = sessionId,
            SessionName = sessionName,
            WorkingDirectory = workingDirectory ?? "C:\\temp"
        };
        _openTerminals.Add(resumeTerminal);
        _activeTerminalKey = resumeTerminal.Key;
        SetStatus($"Resuming session {sessionName ?? sessionId.Substring(0, 8)} from database...", "info");
    }

    /// <summary>
    /// Termina una sessione attiva.
    /// </summary>
    private void KillSession(string sessionId)
    {
        try
        {
            TerminalManager.KillSession(sessionId);
            SetStatus($"Session {sessionId.Substring(0, 8)} killed", "success");
        }
        catch (Exception ex)
        {
            SetStatus($"Error killing session: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Handler chiamato quando il terminal Claude √® stato inizializzato.
    /// Riceve il ConnectionId dal componente Terminal e aggiorna TerminalInstance.
    /// </summary>
    private void HandleClaudeSessionInitialized(string terminalKey, string connectionId)
    {
        // Trova TerminalInstance corrispondente e aggiorna ConnectionId
        var terminal = _openTerminals.FirstOrDefault(t => t.Key == terminalKey);
        if (terminal != null)
        {
            terminal.ConnectionId = connectionId;
            Console.WriteLine($"[Index.razor] Claude terminal {terminalKey.Substring(0, 8)} initialized with ConnectionId {connectionId.Substring(0, 8)}");

            // Se resume (SessionId gi√† noto), imposta DetectedClaudeSessionId immediatamente
            if (!string.IsNullOrEmpty(terminal.SessionId))
            {
                terminal.DetectedClaudeSessionId = terminal.SessionId;
                Console.WriteLine($"[Index.razor] Resume mode - Claude SessionId already known: {terminal.SessionId}");
                StateHasChanged(); // Trigger rendering dell'editor e del PowerShell terminal
            }
            // Per nuove sessioni, OnClaudeSessionIdDetected() verr√† chiamato tramite callback
        }

        SetStatus($"Claude session {connectionId.Substring(0, 8)} initialized successfully", "success");
    }

    /// <summary>
    /// Handler chiamato quando il Claude Session ID viene rilevato da /status.
    /// Aggiorna DetectedClaudeSessionId per attivare l'editor e il terminal PowerShell.
    /// </summary>
    private void OnClaudeSessionIdDetected(string terminalKey, string claudeSessionId)
    {
        var terminal = _openTerminals.FirstOrDefault(t => t.Key == terminalKey);
        if (terminal != null)
        {
            terminal.DetectedClaudeSessionId = claudeSessionId;
            Console.WriteLine($"[Index.razor] Claude SessionId detected for terminal {terminalKey.Substring(0, 8)}: {claudeSessionId}");
            StateHasChanged(); // Trigger rendering del MarkdownEditor e PowerShell terminal
        }
    }

    /// <summary>
    /// Handler chiamato quando il terminal PowerShell √® stato inizializzato.
    /// </summary>
    private void HandlePowerShellSessionInitialized(string terminalKey, string connectionId)
    {
        var terminal = _openTerminals.FirstOrDefault(t => t.Key == terminalKey);
        if (terminal != null)
        {
            terminal.PowerShellConnectionId = connectionId;
            Console.WriteLine($"[Index.razor] PowerShell terminal {terminalKey.Substring(0, 8)} initialized with ConnectionId {connectionId.Substring(0, 8)}");
        }

        SetStatus($"PowerShell session {connectionId.Substring(0, 8)} initialized successfully", "success");
    }

    /// <summary>
    /// Handler chiamato quando il processo Claude termina.
    /// Rimuove il terminal dalla lista e aggiorna la UI.
    /// NOTA: TerminalManager gi√† aggiorna DB status='closed' e rimuove da _activeSessions.
    /// </summary>
    private async Task HandleProcessCompleted(string terminalKey)
    {
        Console.WriteLine($"[Index.razor] Process completed for terminal {terminalKey.Substring(0, 8)}");

        // Trova e rimuovi TerminalInstance dalla lista
        var terminal = _openTerminals.FirstOrDefault(t => t.Key == terminalKey);
        if (terminal != null)
        {
            _openTerminals.Remove(terminal);
            Console.WriteLine($"[Index.razor] Removed terminal {terminalKey.Substring(0, 8)} from list");

            // Se era quello attivo, switcha a un altro o nasconde tutto
            if (_activeTerminalKey == terminalKey)
            {
                _activeTerminalKey = _openTerminals.FirstOrDefault()?.Key;
                Console.WriteLine($"[Index.razor] Active terminal closed, switched to: {_activeTerminalKey?.Substring(0, 8) ?? "none"}");
            }

            SetStatus($"Session {terminal.SessionName ?? terminal.ConnectionId?.Substring(0, 8) ?? "unknown"} closed", "info");
        }

        // Forza aggiornamento UI
        StateHasChanged();

        // Breve delay per permettere al DB di aggiornarsi
        await Task.Delay(500);

        // Notifica NavMenu per aggiornare lista sessioni
        SessionEvents.NotifySessionListChanged();
    }

    /// <summary>
    /// Imposta messaggio di status.
    /// </summary>
    private void SetStatus(string message, string type)
    {
        _statusMessage = message;
        _statusClass = type;
        StateHasChanged();

        // Auto-hide dopo 5 secondi
        _ = Task.Run(async () =>
        {
            await Task.Delay(5000);
            _statusMessage = null;
            await InvokeAsync(StateHasChanged);
        });
    }
}
