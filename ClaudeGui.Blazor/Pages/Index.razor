@page "/"
@using ClaudeGui.Blazor.Components
@using ClaudeGui.Blazor.Services
@using ClaudeGui.Blazor.Models
@inject ITerminalManager TerminalManager
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject DbService DbService
@inject SessionEventService SessionEvents

<PageTitle>ClaudeGui - Terminal Sessions</PageTitle>

<div class="claude-gui-container">
    <!-- Header Section -->
    <div class="header-section">
        <div class="logo-title">
            <h1>ðŸ¤– ClaudeGui</h1>
            <p class="subtitle">Web-based Claude Code Terminal</p>
        </div>
    </div>

    <!-- Terminal Section -->
    @if (_openTerminals.Any())
    {
        <!-- Render tutti i terminal, nascondendo quelli inattivi con display:none -->
        @foreach (var terminal in _openTerminals)
        {
            <div class="terminal-view" style="display: @(terminal.Key == _activeTerminalKey ? "block" : "none")">
                <Terminal @key="@terminal.Key"
                         WorkingDirectory="@terminal.WorkingDirectory"
                         ExistingSessionId="@terminal.SessionId"
                         SessionName="@terminal.SessionName"
                         RunAsAdmin="@terminal.RunAsAdmin"
                         OnSessionInitialized="(connectionId) => HandleSessionInitialized(terminal.Key, connectionId)"
                         OnProcessCompleted="() => HandleProcessCompleted(terminal.Key)" />
            </div>
        }
    }

    <!-- Status Bar -->
    @if (!string.IsNullOrEmpty(_statusMessage))
    {
        <div class="status-bar @_statusClass">
            @_statusMessage
        </div>
    }

    <!-- New Session Modal -->
    <NewSessionModal OnSessionCreated="HandleSessionCreated" />
</div>

@code {
    // Query Parameters (dal NavMenu quando si clicca una sessione)
    [SupplyParameterFromQuery(Name = "sessionId")]
    public string? QuerySessionId { get; set; }

    [SupplyParameterFromQuery(Name = "sessionName")]
    public string? QuerySessionName { get; set; }

    [SupplyParameterFromQuery(Name = "workingDir")]
    public string? QueryWorkingDir { get; set; }

    [SupplyParameterFromQuery(Name = "isOpen")]
    public bool QueryIsOpen { get; set; }

    [SupplyParameterFromQuery(Name = "runAsAdmin")]
    public bool QueryRunAsAdmin { get; set; }

    // State - Multi-terminal support
    private List<TerminalInstance> _openTerminals = new();
    private string? _activeTerminalKey = null; // Chiave del terminal attualmente visualizzato
    private string? _statusMessage = null;
    private string _statusClass = "info";
    private bool _hasAutoLaunched = false; // Flag per evitare multipli auto-launch

    /// <summary>
    /// Rappresenta un'istanza di terminal aperta.
    /// </summary>
    private class TerminalInstance
    {
        public string Key { get; set; } = Guid.NewGuid().ToString();
        public string? ConnectionId { get; set; } // SignalR ConnectionId (impostato dopo init)
        public string? SessionId { get; set; } // Claude Session UUID
        public string? SessionName { get; set; }
        public string WorkingDirectory { get; set; } = "C:\\temp";
        public bool RunAsAdmin { get; set; } = false; // Flag per eseguire come amministratore
    }

    /// <summary>
    /// OnInitializedAsync: carica ultima sessione open all'avvio (solo se nessun query parameter).
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        // Auto-launch ultima sessione open solo se NON ci sono query parameters
        if (string.IsNullOrEmpty(QuerySessionId) && !_hasAutoLaunched)
        {
            try
            {
                // Ottieni ultima sessione open dal DB (OrderByDescending LastActivity)
                var openSessions = await DbService.GetOpenSessionsAsync();
                var lastSession = openSessions.FirstOrDefault();

                if (lastSession != null)
                {
                    _hasAutoLaunched = true;
                    ResumeSession(lastSession.SessionId, lastSession.Name, lastSession.WorkingDirectory, lastSession.RunAsAdmin);
                    SetStatus($"Auto-launched last session: {lastSession.Name ?? lastSession.SessionId.Substring(0, 8)}", "info");
                }
            }
            catch (Exception ex)
            {
                SetStatus($"Error auto-launching last session: {ex.Message}", "error");
            }
        }
    }

    /// <summary>
    /// OnParametersSet: gestisce navigazione da NavMenu tramite query parameters.
    /// Avvia automaticamente il terminal quando vengono passati sessionId e workingDir.
    /// </summary>
    protected override void OnParametersSet()
    {
        // Se abbiamo query parameters per una sessione, avvia il terminal
        if (!string.IsNullOrEmpty(QuerySessionId) && !string.IsNullOrEmpty(QueryWorkingDir))
        {
            // Resume/attach alla sessione selezionata
            ResumeSession(QuerySessionId, QuerySessionName, QueryWorkingDir, QueryRunAsAdmin);
        }
    }

    /// <summary>
    /// Handler chiamato dal NewSessionModal quando una sessione viene creata.
    /// Riceve sessionName e workingDirectory dal modal e avvia il terminal.
    /// La validazione Ã¨ giÃ  stata eseguita dal modal.
    /// </summary>
    private void HandleSessionCreated((string sessionName, string workingDirectory) sessionData)
    {
        // Crea nuovo TerminalInstance e aggiungilo alla lista
        var newTerminal = new TerminalInstance
        {
            SessionName = sessionData.sessionName,
            WorkingDirectory = sessionData.workingDirectory,
            SessionId = null // Nuova sessione (ConnectionId sarÃ  impostato in OnSessionInitialized)
        };

        _openTerminals.Add(newTerminal);
        _activeTerminalKey = newTerminal.Key; // Rendi attivo il nuovo terminal

        SetStatus($"Starting new session '{sessionData.sessionName}'...", "info");
    }

    /// <summary>
    /// Riprende una sessione esistente (attiva o da database).
    /// Se terminal giÃ  aperto in UI â†’ solo switch visualizzazione (NO modifica DB).
    /// Altrimenti crea nuovo terminal con --resume.
    /// </summary>
    private void ResumeSession(string sessionId, string? sessionName, string? workingDirectory = null, bool runAsAdmin = false)
    {
        // CASO 1: Terminal giÃ  aperto in UI â†’ solo switch visualizzazione
        var existingTerminal = _openTerminals.FirstOrDefault(t =>
            t.SessionId == sessionId ||
            t.ConnectionId == sessionId);

        if (existingTerminal != null)
        {
            // Terminal giÃ  presente â†’ solo cambia visualizzazione (NO modifica DB!)
            _activeTerminalKey = existingTerminal.Key;
            SetStatus($"Switched to session {sessionName ?? sessionId.Substring(0, 8)}", "info");
            return;
        }

        // CASO 2: Sessione attiva in TerminalManager ma non in UI â†’ crea terminal per collegarsi
        if (TerminalManager.HasActiveSession(sessionId))
        {
            var connectionId = TerminalManager.GetConnectionIdByClaudeSessionId(sessionId);
            if (connectionId != null)
            {
                var newTerminal = new TerminalInstance
                {
                    SessionId = sessionId,
                    SessionName = sessionName,
                    WorkingDirectory = workingDirectory ?? "C:\\temp",
                    ConnectionId = connectionId,
                    RunAsAdmin = runAsAdmin
                };
                _openTerminals.Add(newTerminal);
                _activeTerminalKey = newTerminal.Key;
                SetStatus($"Attached to running session {sessionName ?? sessionId.Substring(0, 8)}", "success");
                return;
            }
        }

        // CASO 3: Sessione closed nel DB â†’ avvia nuovo processo con --resume
        var resumeTerminal = new TerminalInstance
        {
            SessionId = sessionId,
            SessionName = sessionName,
            WorkingDirectory = workingDirectory ?? "C:\\temp",
            RunAsAdmin = runAsAdmin
        };
        _openTerminals.Add(resumeTerminal);
        _activeTerminalKey = resumeTerminal.Key;
        SetStatus($"Resuming session {sessionName ?? sessionId.Substring(0, 8)} from database...", "info");
    }

    /// <summary>
    /// Termina una sessione attiva.
    /// </summary>
    private void KillSession(string sessionId)
    {
        try
        {
            TerminalManager.KillSession(sessionId);
            SetStatus($"Session {sessionId.Substring(0, 8)} killed", "success");
        }
        catch (Exception ex)
        {
            SetStatus($"Error killing session: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Handler chiamato quando una sessione terminal Ã¨ stata inizializzata.
    /// Riceve il ConnectionId dal componente Terminal e aggiorna TerminalInstance.
    /// </summary>
    private void HandleSessionInitialized(string terminalKey, string connectionId)
    {
        // Trova TerminalInstance corrispondente e aggiorna ConnectionId
        var terminal = _openTerminals.FirstOrDefault(t => t.Key == terminalKey);
        if (terminal != null)
        {
            terminal.ConnectionId = connectionId;
            Console.WriteLine($"[Index.razor] Terminal {terminalKey.Substring(0, 8)} initialized with ConnectionId {connectionId.Substring(0, 8)}");
        }

        SetStatus($"Session {connectionId.Substring(0, 8)} initialized successfully", "success");
    }

    /// <summary>
    /// Handler chiamato quando il processo Claude termina.
    /// Rimuove il terminal dalla lista e aggiorna la UI.
    /// NOTA: TerminalManager giÃ  aggiorna DB status='closed' e rimuove da _activeSessions.
    /// </summary>
    private async Task HandleProcessCompleted(string terminalKey)
    {
        Console.WriteLine($"[Index.razor] Process completed for terminal {terminalKey.Substring(0, 8)}");

        // Trova e rimuovi TerminalInstance dalla lista
        var terminal = _openTerminals.FirstOrDefault(t => t.Key == terminalKey);
        if (terminal != null)
        {
            _openTerminals.Remove(terminal);
            Console.WriteLine($"[Index.razor] Removed terminal {terminalKey.Substring(0, 8)} from list");

            // Se era quello attivo, switcha a un altro o nasconde tutto
            if (_activeTerminalKey == terminalKey)
            {
                _activeTerminalKey = _openTerminals.FirstOrDefault()?.Key;
                Console.WriteLine($"[Index.razor] Active terminal closed, switched to: {_activeTerminalKey?.Substring(0, 8) ?? "none"}");
            }

            SetStatus($"Session {terminal.SessionName ?? terminal.ConnectionId?.Substring(0, 8) ?? "unknown"} closed", "info");
        }

        // Forza aggiornamento UI
        StateHasChanged();

        // Breve delay per permettere al DB di aggiornarsi
        await Task.Delay(500);

        // Notifica NavMenu per aggiornare lista sessioni
        SessionEvents.NotifySessionListChanged();
    }

    /// <summary>
    /// Imposta messaggio di status.
    /// </summary>
    private void SetStatus(string message, string type)
    {
        _statusMessage = message;
        _statusClass = type;
        StateHasChanged();

        // Auto-hide dopo 5 secondi
        _ = Task.Run(async () =>
        {
            await Task.Delay(5000);
            _statusMessage = null;
            await InvokeAsync(StateHasChanged);
        });
    }
}
