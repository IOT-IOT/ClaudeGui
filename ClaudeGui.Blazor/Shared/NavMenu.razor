@using ClaudeGui.Blazor.Models
@using ClaudeGui.Blazor.Models.Entities
@using ClaudeGui.Blazor.Services
@using ClaudeGui.Blazor.Data
@using Microsoft.EntityFrameworkCore
@inject IServiceProvider ServiceProvider
@inject ITerminalManager TerminalManager
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject SessionEventService SessionEvents
@inject ILogger<NavMenu> Logger
@implements IDisposable

<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">ClaudeGui.Blazor</a>
        <button title="Navigation menu" class="navbar-toggler" @onclick="ToggleNavMenu">
            <span class="navbar-toggler-icon"></span>
        </button>
    </div>
</div>

<div class="@NavMenuCssClass" @onclick="ToggleNavMenu" @onclick:stopPropagation>
    <nav class="flex-column" @onclick="() => _showContextMenu = false">
        <!-- Home e New Session -->
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="oi oi-home" aria-hidden="true"></span> Home
            </NavLink>
        </div>
        <div class="nav-item px-3">
            <a class="nav-link" href="#" @onclick="OpenNewSessionModal" @onclick:preventDefault>
                <span class="oi oi-plus" aria-hidden="true"></span> New Session
            </a>
        </div>

        <!-- Separatore -->
        <hr class="nav-separator" />

        <!-- Open Sessions Section -->
        <div class="nav-section">
            <div class="nav-section-header" @onclick="() => ToggleSection(SectionType.Open)">
                <span class="nav-section-icon">@(openExpanded ? "‚ñº" : "‚ñ∂")</span>
                <span class="nav-section-title">Open Sessions (@openSessions.Count)</span>
            </div>

            @if (openExpanded)
            {
                <!-- Search box per Open Sessions -->
                <div class="nav-search-container">
                    <input type="text"
                           class="nav-search-box"
                           placeholder="Search open sessions..."
                           @bind="openSearchTerm"
                           @bind:event="oninput" />
                </div>

                <!-- Lista Open Sessions con Virtualize -->
                <div class="nav-session-list">
                    @if (FilteredOpenSessions.Any())
                    {
                        <Virtualize Items="@FilteredOpenSessions" Context="session">
                            <a class="nav-session-item"
                               href="#"
                               @onclick="() => NavigateToSession(session.ClaudeSessionId ?? session.ConnectionId, session.SessionName, session.WorkingDirectory, true)"
                               @onclick:preventDefault
                               @oncontextmenu="(e) => ShowContextMenu(e, session.ClaudeSessionId ?? session.ConnectionId, session.SessionName, session.WorkingDirectory, true)"
                               @oncontextmenu:preventDefault>
                                <span class="session-status-dot open"></span>
                                <span class="session-name">@(session.SessionName ?? "Unnamed")</span>
                            </a>
                        </Virtualize>
                    }
                    else
                    {
                        <div class="nav-empty-state">
                            @(string.IsNullOrWhiteSpace(openSearchTerm) ? "No open sessions" : "No matches found")
                        </div>
                    }
                </div>
            }
        </div>

        <!-- Closed Sessions Section -->
        <div class="nav-section">
            <div class="nav-section-header" @onclick="() => ToggleSection(SectionType.Closed)">
                <span class="nav-section-icon">@(closedExpanded ? "‚ñº" : "‚ñ∂")</span>
                <span class="nav-section-title">Closed Sessions (@closedSessions.Count)</span>
            </div>

            @if (closedExpanded)
            {
                <!-- Search box per Closed Sessions -->
                <div class="nav-search-container">
                    <input type="text"
                           class="nav-search-box"
                           placeholder="Search closed sessions..."
                           @bind="closedSearchTerm"
                           @bind:event="oninput" />
                </div>

                <!-- Lista Closed Sessions con Virtualize -->
                <div class="nav-session-list">
                    @if (FilteredClosedSessions.Any())
                    {
                        <Virtualize Items="@FilteredClosedSessions" Context="session">
                            <div class="nav-session-item"
                                 @oncontextmenu="(e) => ShowContextMenu(e, session.SessionId, session.Name, session.WorkingDirectory, false)"
                                 @oncontextmenu:preventDefault>
                                <span class="session-status-dot closed"></span>
                                <span class="session-name">@(session.Name ?? "Unnamed")</span>
                            </div>
                        </Virtualize>
                    }
                    else
                    {
                        <div class="nav-empty-state">
                            @(string.IsNullOrWhiteSpace(closedSearchTerm) ? "No closed sessions" : "No matches found")
                        </div>
                    }
                </div>
            }
        </div>
    </nav>

    <!-- Context Menu -->
    @if (_showContextMenu)
    {
        <div class="context-menu" style="left: @(_contextMenuX)px; top: @(_contextMenuY)px;" @onclick:stopPropagation>
            @if (_contextMenuIsOpen)
            {
                <!-- Menu per Open Sessions -->
                <div class="context-menu-item" @onclick="HandleCloseSession">
                    üóô Chiudi
                </div>
            }
            else
            {
                <!-- Menu per Closed Sessions -->
                <div class="context-menu-item" @onclick="HandleOpenSession">
                    ‚ñ∂Ô∏è Apri
                </div>
            }
        </div>
    }
</div>

@code {
    // Enumerazione per tipo sezione
    private enum SectionType { Open, Closed }

    // State per menu mobile
    private bool collapseNavMenu = true;
    private string? NavMenuCssClass => collapseNavMenu ? "collapse" : null;

    // State per sessioni
    private List<ActiveSessionInfo> openSessions = new();
    private List<Session> closedSessions = new();

    // State per sezioni collassabili
    private bool openExpanded = true;
    private bool closedExpanded = false;

    // State per ricerca
    private string openSearchTerm = "";
    private string closedSearchTerm = "";

    // State per menu contestuale
    private bool _showContextMenu = false;
    private string? _contextMenuSessionId = null;
    private string? _contextMenuSessionName = null;
    private string? _contextMenuWorkingDirectory = null;
    private bool _contextMenuIsOpen = false; // true = Open Session, false = Closed Session
    private double _contextMenuX = 0;
    private double _contextMenuY = 0;

    // Sessioni filtrate (computed properties)
    private List<ActiveSessionInfo> FilteredOpenSessions =>
        string.IsNullOrWhiteSpace(openSearchTerm)
            ? openSessions
            : openSessions.Where(s => (s.SessionName ?? "").Contains(openSearchTerm, StringComparison.OrdinalIgnoreCase)).ToList();

    private List<Session> FilteredClosedSessions =>
        string.IsNullOrWhiteSpace(closedSearchTerm)
            ? closedSessions
            : closedSessions.Where(s => (s.Name ?? "").Contains(closedSearchTerm, StringComparison.OrdinalIgnoreCase)).ToList();

    // Flag per primo render
    private bool _firstRender = true;

    /// <summary>
    /// OnInitializedAsync: carica le sessioni all'avvio del componente.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        // Sottoscrivi eventi di sessione
        SessionEvents.SessionListChanged += OnSessionListChanged;

        // Carica sessioni subito (per mostrare lista iniziale)
        await LoadSessions();
    }

    /// <summary>
    /// Handler per evento SessionListChanged.
    /// Ricarica le sessioni e aggiorna UI.
    /// </summary>
    private async void OnSessionListChanged(object? sender, EventArgs e)
    {
        await LoadSessions();
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// OnAfterRenderAsync: non pi√π necessario con il sistema event-driven migliorato.
    /// SessionEventService ora garantisce aggiornamenti real-time affidabili.
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Polling workaround rimosso: ora TerminalManager notifica SessionEventService
        // dopo che il DB √® aggiornato, garantendo refresh immediato e deterministico
        await Task.CompletedTask;
    }

    /// <summary>
    /// Carica Open Sessions (da database) e Closed Sessions (da database).
    /// IMPORTANTE: Open Sessions vengono caricate dal DB (status='open'), NON da TerminalManager.
    /// Questo permette di mostrare tutte le sessioni aperte anche se il processo non √® in memoria.
    /// </summary>
    private async Task LoadSessions()
    {
        try
        {
            // Recupera DbContextFactory opzionalmente
            var dbContextFactory = ServiceProvider.GetService<IDbContextFactory<ClaudeGuiDbContext>>();
            if (dbContextFactory == null) return;

            await using var db = await dbContextFactory.CreateDbContextAsync();

            // Carica Open Sessions dal database (status = 'open')
            var dbOpenSessions = await db.Sessions
                .AsNoTracking()
                .Where(s => s.Status == "open" && !s.Excluded)
                .OrderByDescending(s => s.LastActivity) // Ordina per LastActivity (pi√π recente)
                .ToListAsync();

            // Converti a ActiveSessionInfo per compatibilit√† con UI
            openSessions = dbOpenSessions.Select(s => new ActiveSessionInfo
            {
                ClaudeSessionId = s.SessionId,
                SessionName = s.Name ?? "Unnamed",
                WorkingDirectory = s.WorkingDirectory ?? "C:\\temp",
                CreatedAt = s.CreatedAt,
                // ConnectionId: controllare se processo in memoria
                ConnectionId = TerminalManager.GetConnectionIdByClaudeSessionId(s.SessionId)
            }).ToList();

            // Carica Closed Sessions dal database (status = 'closed')
            closedSessions = await db.Sessions
                .AsNoTracking()
                .Where(s => s.Status == "closed" && !s.Excluded) // Solo sessioni chiuse, escludi sessioni di sistema
                .OrderByDescending(s => s.LastActivity) // Ordina per LastActivity (pi√π recente)
                .ToListAsync();
        }
        catch (Exception ex)
        {
            // Log error (opzionale)
            Console.Error.WriteLine($"Error loading sessions: {ex.Message}");
            openSessions = new List<ActiveSessionInfo>();
            closedSessions = new List<Session>();
        }
    }

    /// <summary>
    /// Toggle visibilit√† sezione (Open/Closed).
    /// </summary>
    private void ToggleSection(SectionType section)
    {
        if (section == SectionType.Open)
            openExpanded = !openExpanded;
        else
            closedExpanded = !closedExpanded;
    }

    /// <summary>
    /// Toggle menu mobile.
    /// </summary>
    private void ToggleNavMenu()
    {
        collapseNavMenu = !collapseNavMenu;
    }

    /// <summary>
    /// Naviga alla sessione selezionata tramite query parameters.
    /// </summary>
    private void NavigateToSession(string? sessionId, string? sessionName, string? workingDirectory, bool isOpen)
    {
        if (string.IsNullOrEmpty(sessionId))
            return;

        var queryString = $"?sessionId={Uri.EscapeDataString(sessionId)}" +
                          $"&sessionName={Uri.EscapeDataString(sessionName ?? "Unnamed")}" +
                          $"&workingDir={Uri.EscapeDataString(workingDirectory ?? "C:\\temp")}" +
                          $"&isOpen={isOpen}";

        NavigationManager.NavigateTo(queryString);
    }

    /// <summary>
    /// Apre il modal per creare una nuova sessione tramite JavaScript.
    /// </summary>
    private async Task OpenNewSessionModal()
    {
        await JSRuntime.InvokeVoidAsync("ClaudeTerminal.openModal", "newSessionModal");
    }

    /// <summary>
    /// Mostra il menu contestuale per una sessione.
    /// </summary>
    private void ShowContextMenu(Microsoft.AspNetCore.Components.Web.MouseEventArgs e, string sessionId, string? sessionName, string? workingDirectory, bool isOpen)
    {
        Logger.LogInformation("üü° [NavMenu.ShowContextMenu] CALLED - SessionId: {SessionId}, Name: {SessionName}, isOpen: {IsOpen}", sessionId, sessionName, isOpen);
        _contextMenuSessionId = sessionId;
        _contextMenuSessionName = sessionName;
        _contextMenuWorkingDirectory = workingDirectory;
        _contextMenuIsOpen = isOpen;
        _contextMenuX = e.ClientX;
        _contextMenuY = e.ClientY;
        _showContextMenu = true;
        Logger.LogInformation("üü° [NavMenu.ShowContextMenu] Context menu set - _contextMenuIsOpen: {IsOpen}, _showContextMenu: {ShowMenu}", _contextMenuIsOpen, _showContextMenu);
    }

    /// <summary>
    /// Handler per aprire una Closed Session (tasto destro ‚Üí Apri).
    /// </summary>
    private async Task HandleOpenSession()
    {
        Logger.LogInformation("üü¢ [NavMenu.HandleOpenSession] CALLED - SessionId: {SessionId}, Name: {SessionName}", _contextMenuSessionId, _contextMenuSessionName);
        _showContextMenu = false;

        if (string.IsNullOrEmpty(_contextMenuSessionId))
        {
            Logger.LogWarning("‚ö†Ô∏è [NavMenu.HandleOpenSession] ABORTED - SessionId is null or empty");
            return;
        }

        try
        {
            Logger.LogInformation("üü¢ [NavMenu.HandleOpenSession] Navigating to session: {SessionId}", _contextMenuSessionId);
            // Naviga a Index.razor per aprire la sessione con nome e working directory
            // TerminalManager.CreateSession notificher√† SessionEventService dopo l'aggiornamento DB
            // e NavMenu si aggiorner√† automaticamente tramite l'evento SessionListChanged
            NavigateToSession(_contextMenuSessionId, _contextMenuSessionName, _contextMenuWorkingDirectory, false);
            Logger.LogInformation("‚úÖ [NavMenu.HandleOpenSession] Navigation completed for: {SessionId}", _contextMenuSessionId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening session");
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Handler per chiudere una Open Session (tasto destro ‚Üí Chiudi).
    /// Usa graceful shutdown con timeout intelligente.
    /// Il processo terminer√† e ProcessCompleted verr√† chiamato automaticamente per cleanup UI.
    /// </summary>
    private async Task HandleCloseSession()
    {
        Logger.LogInformation("üî¥ [NavMenu.HandleCloseSession] CALLED - SessionId: {SessionId}", _contextMenuSessionId);
        _showContextMenu = false;

        if (string.IsNullOrEmpty(_contextMenuSessionId))
        {
            Logger.LogWarning("‚ö†Ô∏è [NavMenu.HandleCloseSession] ABORTED - SessionId is null or empty");
            return;
        }

        try
        {
            // Ottieni ConnectionId dal ClaudeSessionId
            var connectionId = TerminalManager.GetConnectionIdByClaudeSessionId(_contextMenuSessionId);
            Logger.LogInformation("üî¥ [NavMenu.HandleCloseSession] ConnectionId resolved: {ConnectionId}", connectionId);

            if (connectionId != null)
            {
                Logger.LogInformation("üî¥ [NavMenu.HandleCloseSession] Calling CloseSessionGracefully for: {ConnectionId}", connectionId);
                // ‚úÖ USA graceful shutdown con timeout intelligente e DB update
                // (invia "exit\r", monitora ogni 100ms, force kill dopo 10s)
                // TerminalManager.ProcessCompleted notificher√† SessionEventService dopo l'aggiornamento DB
                // e NavMenu si aggiorner√† automaticamente tramite l'evento SessionListChanged
                await TerminalManager.CloseSessionGracefully(connectionId, updateDatabase: true);
                Logger.LogInformation("‚úÖ [NavMenu.HandleCloseSession] CloseSessionGracefully completed for: {ConnectionId}", connectionId);
            }
            else
            {
                Logger.LogWarning("‚ö†Ô∏è [NavMenu.HandleCloseSession] ConnectionId is NULL for SessionId: {SessionId}", _contextMenuSessionId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error closing session");
        }
    }

    /// <summary>
    /// Metodo pubblico per aggiornare le sessioni (chiamabile da Index.razor).
    /// </summary>
    public async Task RefreshSessions()
    {
        await LoadSessions();
        StateHasChanged();
    }

    /// <summary>
    /// Dispose: rimuove sottoscrizione eventi.
    /// </summary>
    public void Dispose()
    {
        SessionEvents.SessionListChanged -= OnSessionListChanged;
    }
}
